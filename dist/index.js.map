{"version":3,"file":"index.js","sources":["../src/services/storage.ts","../src/utils/api.ts","../src/services/api.ts","../src/services/config.ts","../src/modules/Base.ts","../src/utils/url.ts","../src/modules/Conferences.ts","../src/modules/Devices.ts","../src/modules/Users.ts","../src/index.ts"],"sourcesContent":["class MemoryStorage {\n  state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n\n  set(key: string, value: any) {\n    this.state.set(key, value);\n  }\n\n  get(key: string) {\n    return this.state.get(key) || null;\n  }\n\n  delete(key: string) {\n    this.state.delete(key);\n  }\n}\n\nexport default MemoryStorage;\n","import jwt from \"jsonwebtoken\";\n\ninterface ParsedResponse {\n  status: number;\n  ok: boolean;\n  json: any;\n}\n\nexport const parseResponse = (response: Response) => {\n  return new Promise<ParsedResponse>((resolve) => {\n    response.text().then((body) => {\n      resolve({\n        status: response.status,\n        ok: response.ok,\n        json: body !== \"\" ? JSON.parse(body) : \"{}\",\n      });\n    });\n  });\n};\n\nexport const isTokenInvalid = (token: string) => {\n  try {\n    const { exp: expiration = null } = jwt.decode(token);\n    const currentTimestamp = Math.ceil(new Date().getTime() / 1000);\n    const expirationBuffer = 10;\n    const expirationTimestamp = expiration - expirationBuffer;\n\n    if (currentTimestamp >= expirationTimestamp) {\n      return true;\n    }\n\n    return false;\n  } catch (_) {\n    return true;\n  }\n};\n","import md5 from \"md5\";\nimport StorageService from \"./storage\";\nimport { ConfigOptions } from \"./../types/config\";\nimport { RequestMethods } from \"./../types/request\";\nimport { parseResponse, isTokenInvalid } from \"./../utils/api\";\n\ninterface Credentials {\n  authToken: string;\n  credentials: string;\n  // Account ID used to log in\n  accountId: string;\n  accountName: string;\n  // Account ID used for request\n  currentAccountId: string;\n}\n\nconst createAuthRequest = (\n  config: ConfigOptions,\n  credentials: string,\n  accountName: string\n) => {\n  if (!config.host) {\n    throw new Error(\"You have not specifiend an API host\");\n  }\n\n  return new Promise((resolve, reject) => {\n    fetch(`${config.host}/${config.authEndpoint}`, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        data: {\n          credentials,\n          account_name: accountName,\n        },\n      }),\n    })\n      .then(parseResponse)\n      .then((response) => {\n        if (response.ok) {\n          resolve(response.json);\n        }\n\n        reject(response.json);\n      })\n      .catch((error) => reject(error));\n  });\n};\n\nexport class ApiService {\n  config: ConfigOptions;\n  storage: StorageService;\n\n  constructor(config: ConfigOptions) {\n    this.config = config;\n    this.storage = new StorageService();\n  }\n\n  /**\n   *\n   * @param username Username/email used to log in\n   * @param password Password used to log in\n   * @param accountName Account name\n   * @param credentials You can skip both username and password and provide a md5 hash of both e.g. md5(usernema:password)\n   */\n  authenticate(\n    username: string | null,\n    password: string | null,\n    accountName: string,\n    credentials?: string\n  ) {\n    const { config } = this;\n\n    const authCredentials = credentials\n      ? credentials\n      : md5(`${username}:${password}`);\n\n    const authPromise = createAuthRequest(config, authCredentials, accountName);\n\n    authPromise\n      .then((response) => {\n        const credentials = {\n          // @ts-ignore\n          authToken: response.auth_token,\n          credentials: authCredentials,\n          // @ts-ignore\n          accountId: response.data.account_id,\n          // @ts-ignore\n          currentAccountId: response.data.account_id,\n          accountName: accountName,\n        };\n        this.storage.set(\"credentials\", credentials);\n      })\n      .catch(() => {});\n    return authPromise;\n  }\n\n  sendRequest(endpoint: string, method: RequestMethods, body: any = null) {\n    const { config } = this;\n\n    const requestPromise = new Promise((resolve, reject) => {\n      const credentials = this.storage.get(\"credentials\") || {};\n\n      const request = (credentials: Credentials) => {\n        const { authToken, currentAccountId } = credentials;\n\n        if (!authToken || !currentAccountId) {\n          reject(\"User has not been authorized\");\n        }\n\n        // TODO: Add option to extend headers\n        const headers = {\n          \"X-Auth-Token\": authToken,\n          \"Content-Type\": \"application/json\",\n        };\n\n        fetch(`${config.host}/accounts/${currentAccountId}/${endpoint}`, {\n          method,\n          headers,\n          ...(body && { body: JSON.stringify({ data: body }) }),\n        })\n          .then(parseResponse)\n          .then((response) => {\n            if (response.ok) {\n              resolve(response.json);\n            }\n\n            reject(response.json);\n          })\n          .catch((error) => reject(error));\n      };\n\n      if (isTokenInvalid(credentials.authToken)) {\n        // re authenticate and run request with new credentials\n        return this.authenticate(\n          \"\",\n          \"\",\n          credentials.accountName,\n          credentials.credentials\n        )\n          .then(() => request(this.storage.get(\"credentials\")))\n          .catch((error) => reject(error));\n      }\n\n      return request(credentials);\n    });\n\n    return requestPromise;\n  }\n\n  /**\n   *\n   * @param accountId ID of the account you want to masquerade\n   */\n  masquerade(accountId: string) {\n    const credentials = this.storage.get(\"credentials\") as Credentials;\n    this.storage.set(\"credentials\", {\n      ...credentials,\n      currentAccountId: accountId,\n    });\n  }\n\n  /**\n   * Stops masquerading and uses original account ID\n   */\n  stopMasquerading() {\n    const credentials = this.storage.get(\"credentials\") as Credentials;\n    this.storage.set(\"credentials\", {\n      ...credentials,\n      currentAccountId: credentials.accountId,\n    });\n  }\n}\n","import { ConfigOptions } from \"./../types/config\";\n\nclass Config {\n  host: string;\n  authEndpoint: string;\n\n  constructor(config: ConfigOptions) {\n    const { host, authEndpoint } = config;\n\n    this.host = host;\n    this.authEndpoint = authEndpoint ?? \"desktop_auth\";\n  }\n}\n\nexport default Config;\n","import { ApiService } from \"./../services/api\";\nimport { buildRequestUrl } from \"../utils/url\";\n\nclass BaseModule {\n  endpoint: string;\n  api: ApiService;\n  // TODO: Add type\n  call: Promise<unknown> | null;\n\n  // shared ApiServive === shared Storage === happiness\n  constructor(api: ApiService) {\n    this.api = api;\n  }\n\n  get(options?: unknown) {\n    this.call = this.api.sendRequest(\n      buildRequestUrl(this.endpoint, options || {}),\n      \"GET\"\n    );\n    return this.call;\n  }\n\n  getById(id: string) {\n    this.call = this.api.sendRequest(`${this.endpoint}/${id}`, \"GET\");\n    return this.call;\n  }\n\n  update(id: string, data: unknown) {\n    this.call = this.api.sendRequest(`${this.endpoint}/${id}`, \"PATCH\", data);\n    return this.call;\n  }\n}\n\nexport default BaseModule;\n","import { URLParams } from \"./../types/request\";\n\nconst formatQueryString = (key: string, value: string) => {\n  return `${key}=${value}`;\n};\n\nconst buildUrlQueryParams = ({ paginate }: URLParams) => {\n  let params = {};\n\n  if (paginate) {\n    params = { ...params, paginate };\n  }\n\n  return Object.keys(params)\n    .map((key) => formatQueryString(key, params[key]))\n    .join(\"&\");\n};\n\nexport const buildRequestUrl = (endpoint: string, params: URLParams) => {\n  if (params.paginate) {\n    const urlParamsString = buildUrlQueryParams(params);\n    return `${endpoint}?${urlParamsString}`;\n  }\n\n  return endpoint;\n};\n","import { ApiService } from \"./../services/api\";\nimport BaseModule from \"./Base\";\n\ntype MemberConfig = {\n  pins: string[];\n  numbers: string[];\n  join_muted: boolean;\n  join_deaf: boolean;\n};\n\ninterface Conference {\n  id: string;\n  name: string;\n  features: [];\n  flags: [];\n  conference_numbers: string[];\n  member: MemberConfig;\n  moderator: MemberConfig;\n}\nclass Conferences extends BaseModule {\n  call: Promise<unknown> | null;\n\n  constructor(api: ApiService) {\n    super(api);\n    this.endpoint = \"conferences\";\n  }\n\n  get() {\n    this.call = this.api.sendRequest(this.endpoint, \"GET\");\n    return this.call as Promise<{ data: Conference[] }>;\n  }\n}\n\nexport default Conferences;\n","import { ApiService } from \"../services/api\";\nimport BaseModule from \"./Base\";\n\ntype Device = {\n  application: { id: string; name: string };\n  call_restriction: {};\n  contact_list: {};\n  device_type: string;\n  enabled: boolean;\n  exclude_from_queues: boolean;\n  id: string;\n  media: {};\n  music_on_hold: {};\n  name: string;\n  owner_id: string;\n  sip: {\n    invite_format: string;\n    method: \"password\";\n    username: string;\n    password: string;\n    expire_seconds: number;\n  };\n  do_not_disturb?: { enabled: boolean };\n};\n\ntype DeviceUpdate = {\n  do_not_disturb?: {\n    enabled: boolean;\n  };\n};\n\nclass Devices extends BaseModule {\n  get: () => Promise<{ data: Device[] }>;\n  getById: (id: string) => Promise<{ data: Device }>;\n  update: (id: string, data: DeviceUpdate) => Promise<{ data: Device }>;\n\n  constructor(api: ApiService) {\n    super(api);\n    this.endpoint = \"devices\";\n  }\n}\n\nexport default Devices;\n","import { ApiService } from \"./../services/api\";\nimport BaseModule from \"./Base\";\n\ntype URLParams = {\n  paginate?: boolean;\n};\n\ntype User = {\n  id: string;\n  email: string;\n  enabled: boolean;\n  features: string[];\n  first_name: string;\n  last_name: string;\n  presence_id: string;\n  priv_level: string;\n  username: string;\n};\n\nclass Users extends BaseModule {\n  get: (options?: URLParams) => Promise<{ data: User[] }>;\n  getById: (id: string) => Promise<{ data: User }>;\n\n  constructor(api: ApiService) {\n    super(api);\n    this.endpoint = \"users\";\n  }\n}\n\nexport default Users;\n","import { ApiService } from \"./services/api\";\nimport Config from \"./services/config\";\n// modules\nimport Conferences from \"./modules/Conferences\";\nimport Devices from \"./modules/Devices\";\nimport Users from \"./modules/Users\";\n// types\nimport { ConfigOptions } from \"./types/config\";\n\nclass KazooSDK {\n  config: ConfigOptions;\n  api: ApiService;\n  Conferences: Conferences;\n  Devices: Devices;\n  Users: Users;\n\n  constructor(config: ConfigOptions) {\n    this.config = config;\n    this.api = new ApiService(config);\n\n    // SDK modules / endpoints\n    this.Conferences = new Conferences(this.api);\n    this.Devices = new Devices(this.api);\n    this.Users = new Users(this.api);\n  }\n\n  /**\n   *\n   * @param username Username/email used to log in\n   * @param password Password used to log in\n   * @param accountName Account name\n   * @param credentials You can skip both username and password and provide a md5 hash of both e.g. md5(usernema:password)\n   */\n  authenticate(\n    username: string | null,\n    password: string | null,\n    accountName: string,\n    credentials?: string\n  ) {\n    return this.api.authenticate(username, password, accountName, credentials);\n  }\n}\n\nexport const sdk = (config: ConfigOptions) => new KazooSDK(new Config(config));\n"],"names":["MemoryStorage","this","state","Map","set","key","value","get","parseResponse","response","Promise","resolve","text","then","body","status","ok","json","JSON","parse","ApiService","config","storage","StorageService","authenticate","username","password","accountName","credentials","authCredentials","md5","authPromise","host","Error","reject","fetch","authEndpoint","method","headers","Content-Type","stringify","data","account_name","error","createAuthRequest","_this","authToken","auth_token","accountId","account_id","currentAccountId","sendRequest","endpoint","_this2","request","X-Auth-Token","token","jwt","decode","exp","expiration","Math","ceil","Date","getTime","_","isTokenInvalid","masquerade","stopMasquerading","Config","BaseModule","api","options","call","params","paginate","Object","keys","map","formatQueryString","join","buildUrlQueryParams","getById","id","update","Conferences","Devices","Users","KazooSDK"],"mappings":"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"}