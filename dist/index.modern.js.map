{"version":3,"file":"index.modern.js","sources":["../src/services/storage.ts","../src/utils/api.ts","../src/services/api.ts","../src/services/config.ts","../src/modules/Conferences.ts","../src/modules/Users.ts","../src/index.ts"],"sourcesContent":["class MemoryStorage {\n  state: Map<string, any>;\n\n  constructor() {\n    this.state = new Map();\n  }\n\n  set(key: string, value: any) {\n    this.state.set(key, value);\n  }\n\n  get(key: string) {\n    return this.state.get(key) || null;\n  }\n\n  delete(key: string) {\n    this.state.delete(key);\n  }\n}\n\nexport default MemoryStorage;\n","import jwt from \"jsonwebtoken\";\n\ninterface ParsedResponse {\n  status: number;\n  ok: boolean;\n  json: any;\n}\n\nexport const parseResponse = (response: Response) => {\n  return new Promise<ParsedResponse>((resolve) => {\n    response.text().then((body) => {\n      resolve({\n        status: response.status,\n        ok: response.ok,\n        json: body !== \"\" ? JSON.parse(body) : \"{}\",\n      });\n    });\n  });\n};\n\nexport const isTokenInvalid = (token: string) => {\n  try {\n    const { exp: expiration = null } = jwt.decode(token);\n    const currentTimestamp = Math.ceil(new Date().getTime() / 1000);\n    const expirationBuffer = 10;\n    const expirationTimestamp = expiration - expirationBuffer;\n\n    if (currentTimestamp >= expirationTimestamp) {\n      return true;\n    }\n\n    return false;\n  } catch (_) {\n    return true;\n  }\n};\n","import md5 from \"md5\";\nimport StorageService from \"./storage\";\nimport { ConfigOptions } from \"./../types/config\";\nimport { RequestMethods } from \"./../types/request\";\nimport { parseResponse, isTokenInvalid } from \"./../utils/api\";\n\ninterface Credentials {\n  authToken: string;\n  credentials: string;\n  // Account ID used to log in\n  accountId: string;\n  accountName: string;\n  // Account ID used for request\n  currentAccountId: string;\n}\n\nconst createAuthRequest = (\n  config: ConfigOptions,\n  credentials: string,\n  accountName: string\n) => {\n  if (!config.host) {\n    throw new Error(\"You have not specifiend an API host\");\n  }\n\n  return new Promise((resolve, reject) => {\n    fetch(`${config.host}/${config.authEndpoint}`, {\n      method: \"PUT\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n      },\n      body: JSON.stringify({\n        data: {\n          credentials,\n          account_name: accountName,\n        },\n      }),\n    })\n      .then(parseResponse)\n      .then((response) => {\n        if (response.ok) {\n          resolve(response.json);\n        }\n\n        reject(response.json);\n      })\n      .catch((error) => reject(error));\n  });\n};\n\nexport class ApiService {\n  config: ConfigOptions;\n  storage: StorageService;\n\n  constructor(config: ConfigOptions) {\n    this.config = config;\n    this.storage = new StorageService();\n  }\n\n  /**\n   *\n   * @param username Username/email used to log in\n   * @param password Password used to log in\n   * @param accountName Account name\n   * @param credentials You can skip both username and password and provide a md5 hash of both e.g. md5(usernema:password)\n   */\n  authenticate(\n    username: string,\n    password: string,\n    accountName: string,\n    credentials?: string\n  ) {\n    const { config } = this;\n\n    const authCredentials = credentials\n      ? credentials\n      : md5(`${username}:${password}`);\n\n    const authPromise = createAuthRequest(config, authCredentials, accountName);\n\n    authPromise\n      .then((response) => {\n        const credentials = {\n          // @ts-ignore\n          authToken: response.auth_token,\n          credentials: authCredentials,\n          // @ts-ignore\n          accountId: response.data.account_id,\n          // @ts-ignore\n          currentAccountId: response.data.account_id,\n          accountName: accountName,\n        };\n        this.storage.set(\"credentials\", credentials);\n      })\n      .catch(() => {});\n    return authPromise;\n  }\n\n  sendRequest(endpoint: string, method: RequestMethods) {\n    const { config } = this;\n\n    const requestPromise = new Promise((resolve, reject) => {\n      const credentials = this.storage.get(\"credentials\") || {};\n\n      const request = (credentials: Credentials) => {\n        const { authToken, currentAccountId } = credentials;\n\n        if (!authToken || !currentAccountId) {\n          reject(\"User has not been authorized\");\n        }\n\n        // TODO: Add option to extend headers\n        const headers = {\n          \"X-Auth-Token\": authToken,\n          \"Content-Type\": \"application/json\",\n        };\n\n        fetch(`${config.host}/accounts/${currentAccountId}/${endpoint}`, {\n          method,\n          headers,\n        })\n          .then(parseResponse)\n          .then((response) => {\n            if (response.ok) {\n              resolve(response.json);\n            }\n\n            reject(response.json);\n          })\n          .catch((error) => reject(error));\n      };\n\n      if (isTokenInvalid(credentials.authToken)) {\n        // re authenticate and run request with new credentials\n        /* return this.authenticate(\n           \"\",\n           \"\",\n           credentials.accountName,\n           credentials.credentials\n         )\n           .then(() => request(getCredentials(this.storage)))\n           .catch((error) => reject(error)); */\n      }\n\n      return request(credentials);\n    });\n\n    return requestPromise;\n  }\n\n  /**\n   *\n   * @param accountId ID of the account you want to masquerade\n   */\n  masquerade(accountId: string) {\n    const credentials = this.storage.get(\"credentials\") as Credentials;\n    this.storage.set(\"credentials\", {\n      ...credentials,\n      currentAccountId: accountId,\n    });\n  }\n\n  /**\n   * Stops masquerading and uses original account ID\n   */\n  stopMasquerading() {\n    const credentials = this.storage.get(\"credentials\") as Credentials;\n    this.storage.set(\"credentials\", {\n      ...credentials,\n      currentAccountId: credentials.accountId,\n    });\n  }\n}\n","import { ConfigOptions } from \"./../types/config\";\n\nclass Config {\n  host: string;\n  authEndpoint: string;\n\n  constructor(config: ConfigOptions) {\n    const { host, authEndpoint } = config;\n\n    this.host = host;\n    this.authEndpoint = authEndpoint ?? \"desktop_auth\";\n  }\n}\n\nexport default Config;\n","import { ApiService } from \"./../services/api\";\n\nclass Conferences {\n  endpoint: string;\n  api: ApiService;\n  // TODO: Add type\n  call: Promise<unknown> | null;\n\n  constructor(api: ApiService) {\n    this.endpoint = \"conferences\";\n    this.api = api;\n  }\n\n  // TODO: add type\n  get() {\n    this.call = this.api.sendRequest(this.endpoint, \"GET\");\n    return this.call;\n  }\n}\n\nexport default Conferences;\n","import { ApiService } from \"./../services/api\";\n\nclass Users {\n  endpoint: string;\n  api: ApiService;\n  // TODO: Add type\n  call: Promise<unknown> | null;\n\n  constructor(api: ApiService) {\n    this.endpoint = \"users\";\n    this.api = api;\n  }\n\n  // TODO: add type\n  get() {\n    this.call = this.api.sendRequest(this.endpoint, \"GET\");\n    return this.call;\n  }\n}\n\nexport default Users;\n","import { ApiService } from \"./services/api\";\nimport Config from \"./services/config\";\n// modules\nimport Conferences from \"./modules/Conferences\";\nimport Users from \"./modules/Users\";\n// types\nimport { ConfigOptions } from \"./types/config\";\n\nclass KazooSDK {\n  config: ConfigOptions;\n  api: ApiService;\n  Conferences: Conferences;\n  Users: Users;\n\n  constructor(config: ConfigOptions) {\n    this.config = config;\n    this.api = new ApiService(config);\n\n    // SDK modules / endpoints\n    this.Conferences = new Conferences(this.api);\n    this.Users = new Users(this.api);\n  }\n\n  /**\n   *\n   * @param username Username/email used to log in\n   * @param password Password used to log in\n   * @param accountName Account name\n   * @param credentials You can skip both username and password and provide a md5 hash of both e.g. md5(usernema:password)\n   */\n  authenticate(\n    username: string,\n    password: string,\n    accountName: string,\n    credentials?: string\n  ) {\n    return this.api.authenticate(username, password, accountName, credentials);\n  }\n}\n\nexport const sdk = (config: ConfigOptions) => new KazooSDK(new Config(config));\n"],"names":["MemoryStorage","constructor","this","state","Map","set","key","value","get","delete","parseResponse","response","Promise","resolve","text","then","body","status","ok","json","JSON","parse","ApiService","config","storage","StorageService","authenticate","username","password","accountName","credentials","authCredentials","md5","authPromise","host","Error","reject","fetch","authEndpoint","method","headers","Content-Type","stringify","data","account_name","catch","error","createAuthRequest","authToken","auth_token","accountId","account_id","currentAccountId","sendRequest","endpoint","token","exp","expiration","jwt","decode","Math","ceil","Date","getTime","_","isTokenInvalid","X-Auth-Token","request","masquerade","stopMasquerading","Config","Conferences","api","call","Users","KazooSDK","sdk"],"mappings":"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"}